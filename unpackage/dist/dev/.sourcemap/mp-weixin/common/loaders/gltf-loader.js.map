{"version":3,"file":"gltf-loader.js","sources":["common/loaders/gltf-loader.js"],"sourcesContent":["export function registerGLTFLoader(THREE) {\n\n  /**\n * @author Rich Tibbett / https://github.com/richtr\n * @author mrdoob / http://mrdoob.com/\n * @author Tony Parisi / http://www.tonyparisi.com/\n * @author Takahiro / https://github.com/takahirox\n * @author Don McCurdy / https://www.donmccurdy.com\n */\n\n  THREE.GLTFLoader = (function () {\n\n    function GLTFLoader(manager) {\n\n      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;\n      this.dracoLoader = null;\n      this.ddsLoader = null;\n\n    }\n\n    GLTFLoader.prototype = {\n\n      constructor: GLTFLoader,\n\n      crossOrigin: 'anonymous',\n\n      load: function (url, onLoad, onProgress, onError) {\n\n        var scope = this;\n\n        var resourcePath;\n\n        if (this.resourcePath !== undefined) {\n\n          resourcePath = this.resourcePath;\n\n        } else if (this.path !== undefined) {\n\n          resourcePath = this.path;\n\n        } else {\n\n          resourcePath = THREE.LoaderUtils.extractUrlBase(url);\n\n        }\n\n        // Tells the LoadingManager to track an extra item, which resolves after\n        // the model is fully loaded. This means the count of items loaded will\n        // be incorrect, but ensures manager.onLoad() does not fire early.\n        scope.manager.itemStart(url);\n\n        var _onError = function (e) {\n\n          if (onError) {\n\n            onError(e);\n\n          } else {\n\n            console.error(e);\n\n          }\n\n          scope.manager.itemError(url);\n          scope.manager.itemEnd(url);\n\n        };\n\n        var loader = new THREE.FileLoader(scope.manager);\n\n        loader.setPath(this.path);\n        loader.setResponseType('arraybuffer');\n\n        if (scope.crossOrigin === 'use-credentials') {\n\n          loader.setWithCredentials(true);\n\n        }\n\n        loader.load(url, function (data) {\n\n          try {\n\n            scope.parse(data, resourcePath, function (gltf) {\n\n              onLoad(gltf);\n\n              scope.manager.itemEnd(url);\n\n            }, _onError);\n\n          } catch (e) {\n\n            _onError(e);\n\n          }\n\n        }, onProgress, _onError);\n\n      },\n\n      setCrossOrigin: function (value) {\n\n        this.crossOrigin = value;\n        return this;\n\n      },\n\n      setPath: function (value) {\n\n        this.path = value;\n        return this;\n\n      },\n\n      setResourcePath: function (value) {\n\n        this.resourcePath = value;\n        return this;\n\n      },\n\n      setDRACOLoader: function (dracoLoader) {\n\n        this.dracoLoader = dracoLoader;\n        return this;\n\n      },\n\n      setDDSLoader: function (ddsLoader) {\n\n        this.ddsLoader = ddsLoader;\n        return this;\n\n      },\n\n      parse: function (data, path, onLoad, onError) {\n\n        var content;\n        var extensions = {};\n\n        if (typeof data === 'string') {\n\n          content = data;\n\n        } else {\n\n          var magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n\n          if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n\n            try {\n\n              extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n\n            } catch (error) {\n\n              if (onError) onError(error);\n              return;\n\n            }\n\n            content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n\n          } else {\n\n            content = THREE.LoaderUtils.decodeText(new Uint8Array(data));\n\n          }\n\n        }\n\n        var json = JSON.parse(content);\n\n        if (json.asset === undefined || json.asset.version[0] < 2) {\n\n          if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.'));\n          return;\n\n        }\n\n        if (json.extensionsUsed) {\n\n          for (var i = 0; i < json.extensionsUsed.length; ++i) {\n\n            var extensionName = json.extensionsUsed[i];\n            var extensionsRequired = json.extensionsRequired || [];\n\n            switch (extensionName) {\n\n              case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:\n                extensions[extensionName] = new GLTFLightsExtension(json);\n                break;\n\n              case EXTENSIONS.KHR_MATERIALS_UNLIT:\n                extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n                break;\n\n              case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n                extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n                break;\n\n              case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n                extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n                break;\n\n              case EXTENSIONS.MSFT_TEXTURE_DDS:\n                extensions[EXTENSIONS.MSFT_TEXTURE_DDS] = new GLTFTextureDDSExtension(this.ddsLoader);\n                break;\n\n              case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n                extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] = new GLTFTextureTransformExtension();\n                break;\n\n              default:\n\n                if (extensionsRequired.indexOf(extensionName) >= 0) {\n\n                  console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n\n                }\n\n            }\n\n          }\n\n        }\n\n        var parser = new GLTFParser(json, extensions, {\n\n          path: path || this.resourcePath || '',\n          crossOrigin: this.crossOrigin,\n          manager: this.manager\n\n        });\n\n        parser.parse(onLoad, onError);\n\n      }\n\n    };\n\n    /* GLTFREGISTRY */\n\n    function GLTFRegistry() {\n\n      var objects = {};\n\n      return {\n\n        get: function (key) {\n\n          return objects[key];\n\n        },\n\n        add: function (key, object) {\n\n          objects[key] = object;\n\n        },\n\n        remove: function (key) {\n\n          delete objects[key];\n\n        },\n\n        removeAll: function () {\n\n          objects = {};\n\n        }\n\n      };\n\n    }\n\n    /*********************************/\n    /********** EXTENSIONS ***********/\n    /*********************************/\n\n    var EXTENSIONS = {\n      KHR_BINARY_GLTF: 'KHR_binary_glTF',\n      KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n      KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n      KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n      KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n      KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n      MSFT_TEXTURE_DDS: 'MSFT_texture_dds'\n    };\n\n    /**\n     * DDS Texture Extension\n     *\n     * Specification:\n     * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds\n     *\n     */\n    function GLTFTextureDDSExtension(ddsLoader) {\n\n      if (!ddsLoader) {\n\n        throw new Error('THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader');\n\n      }\n\n      this.name = EXTENSIONS.MSFT_TEXTURE_DDS;\n      this.ddsLoader = ddsLoader;\n\n    }\n\n    /**\n     * Lights Extension\n     *\n     * Specification: PENDING\n     */\n    function GLTFLightsExtension(json) {\n\n      this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n      var extension = (json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL]) || {};\n      this.lightDefs = extension.lights || [];\n\n    }\n\n    GLTFLightsExtension.prototype.loadLight = function (lightIndex) {\n\n      var lightDef = this.lightDefs[lightIndex];\n      var lightNode;\n\n      var color = new THREE.Color(0xffffff);\n      if (lightDef.color !== undefined) color.fromArray(lightDef.color);\n\n      var range = lightDef.range !== undefined ? lightDef.range : 0;\n\n      switch (lightDef.type) {\n\n        case 'directional':\n          lightNode = new THREE.DirectionalLight(color);\n          lightNode.target.position.set(0, 0, - 1);\n          lightNode.add(lightNode.target);\n          break;\n\n        case 'point':\n          lightNode = new THREE.PointLight(color);\n          lightNode.distance = range;\n          break;\n\n        case 'spot':\n          lightNode = new THREE.SpotLight(color);\n          lightNode.distance = range;\n          // Handle spotlight properties.\n          lightDef.spot = lightDef.spot || {};\n          lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n          lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n          lightNode.angle = lightDef.spot.outerConeAngle;\n          lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n          lightNode.target.position.set(0, 0, - 1);\n          lightNode.add(lightNode.target);\n          break;\n\n        default:\n          throw new Error('THREE.GLTFLoader: Unexpected light type, \"' + lightDef.type + '\".');\n\n      }\n\n      // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n      // here, because node-level parsing will only override position if explicitly specified.\n      lightNode.position.set(0, 0, 0);\n\n      lightNode.decay = 2;\n\n      if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;\n\n      lightNode.name = lightDef.name || ('light_' + lightIndex);\n\n      return Promise.resolve(lightNode);\n\n    };\n\n    /**\n     * Unlit Materials Extension (pending)\n     *\n     * PR: https://github.com/KhronosGroup/glTF/pull/1163\n     */\n    function GLTFMaterialsUnlitExtension() {\n\n      this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n    }\n\n    GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {\n\n      return THREE.MeshBasicMaterial;\n\n    };\n\n    GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, materialDef, parser) {\n\n      var pending = [];\n\n      materialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n      materialParams.opacity = 1.0;\n\n      var metallicRoughness = materialDef.pbrMetallicRoughness;\n\n      if (metallicRoughness) {\n\n        if (Array.isArray(metallicRoughness.baseColorFactor)) {\n\n          var array = metallicRoughness.baseColorFactor;\n\n          materialParams.color.fromArray(array);\n          materialParams.opacity = array[3];\n\n        }\n\n        if (metallicRoughness.baseColorTexture !== undefined) {\n\n          pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n\n        }\n\n      }\n\n      return Promise.all(pending);\n\n    };\n\n    /* BINARY EXTENSION */\n    var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n    var BINARY_EXTENSION_HEADER_LENGTH = 12;\n    var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\n    function GLTFBinaryExtension(data) {\n\n      this.name = EXTENSIONS.KHR_BINARY_GLTF;\n      this.content = null;\n      this.body = null;\n\n      var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n\n      this.header = {\n        magic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n        version: headerView.getUint32(4, true),\n        length: headerView.getUint32(8, true)\n      };\n\n      if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n\n        throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\n\n      } else if (this.header.version < 2.0) {\n\n        throw new Error('THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.');\n\n      }\n\n      var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n      var chunkIndex = 0;\n\n      while (chunkIndex < chunkView.byteLength) {\n\n        var chunkLength = chunkView.getUint32(chunkIndex, true);\n        chunkIndex += 4;\n\n        var chunkType = chunkView.getUint32(chunkIndex, true);\n        chunkIndex += 4;\n\n        if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n\n          var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n          this.content = THREE.LoaderUtils.decodeText(contentArray);\n\n        } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n\n          var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n          this.body = data.slice(byteOffset, byteOffset + chunkLength);\n\n        }\n\n        // Clients must ignore chunks with unknown types.\n\n        chunkIndex += chunkLength;\n\n      }\n\n      if (this.content === null) {\n\n        throw new Error('THREE.GLTFLoader: JSON content not found.');\n\n      }\n\n    }\n\n    /**\n     * DRACO Mesh Compression Extension\n     *\n     * Specification: https://github.com/KhronosGroup/glTF/pull/874\n     */\n    function GLTFDracoMeshCompressionExtension(json, dracoLoader) {\n\n      if (!dracoLoader) {\n\n        throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\n\n      }\n\n      this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n      this.json = json;\n      this.dracoLoader = dracoLoader;\n\n    }\n\n    GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {\n\n      var json = this.json;\n      var dracoLoader = this.dracoLoader;\n      var bufferViewIndex = primitive.extensions[this.name].bufferView;\n      var gltfAttributeMap = primitive.extensions[this.name].attributes;\n      var threeAttributeMap = {};\n      var attributeNormalizedMap = {};\n      var attributeTypeMap = {};\n\n      for (var attributeName in gltfAttributeMap) {\n\n        var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n\n        threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n\n      }\n\n      for (attributeName in primitive.attributes) {\n\n        var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n\n        if (gltfAttributeMap[attributeName] !== undefined) {\n\n          var accessorDef = json.accessors[primitive.attributes[attributeName]];\n          var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n\n          attributeTypeMap[threeAttributeName] = componentType;\n          attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n\n        }\n\n      }\n\n      return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n\n        return new Promise(function (resolve) {\n\n          dracoLoader.decodeDracoFile(bufferView, function (geometry) {\n\n            for (var attributeName in geometry.attributes) {\n\n              var attribute = geometry.attributes[attributeName];\n              var normalized = attributeNormalizedMap[attributeName];\n\n              if (normalized !== undefined) attribute.normalized = normalized;\n\n            }\n\n            resolve(geometry);\n\n          }, threeAttributeMap, attributeTypeMap);\n\n        });\n\n      });\n\n    };\n\n    /**\n     * Texture Transform Extension\n     *\n     * Specification:\n     */\n    function GLTFTextureTransformExtension() {\n\n      this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n    }\n\n    GLTFTextureTransformExtension.prototype.extendTexture = function (texture, transform) {\n\n      texture = texture.clone();\n\n      if (transform.offset !== undefined) {\n\n        texture.offset.fromArray(transform.offset);\n\n      }\n\n      if (transform.rotation !== undefined) {\n\n        texture.rotation = transform.rotation;\n\n      }\n\n      if (transform.scale !== undefined) {\n\n        texture.repeat.fromArray(transform.scale);\n\n      }\n\n      if (transform.texCoord !== undefined) {\n\n        console.warn('THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.');\n\n      }\n\n      texture.needsUpdate = true;\n\n      return texture;\n\n    };\n\n    /**\n     * Specular-Glossiness Extension\n     *\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n     */\n    function GLTFMaterialsPbrSpecularGlossinessExtension() {\n\n      return {\n\n        name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n\n        specularGlossinessParams: [\n          'color',\n          'map',\n          'lightMap',\n          'lightMapIntensity',\n          'aoMap',\n          'aoMapIntensity',\n          'emissive',\n          'emissiveIntensity',\n          'emissiveMap',\n          'bumpMap',\n          'bumpScale',\n          'normalMap',\n          'displacementMap',\n          'displacementScale',\n          'displacementBias',\n          'specularMap',\n          'specular',\n          'glossinessMap',\n          'glossiness',\n          'alphaMap',\n          'envMap',\n          'envMapIntensity',\n          'refractionRatio',\n        ],\n\n        getMaterialType: function () {\n\n          return THREE.ShaderMaterial;\n\n        },\n\n        extendParams: function (materialParams, materialDef, parser) {\n\n          var pbrSpecularGlossiness = materialDef.extensions[this.name];\n\n          var shader = THREE.ShaderLib['standard'];\n\n          var uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n          var specularMapParsFragmentChunk = [\n            '#ifdef USE_SPECULARMAP',\n            '\tuniform sampler2D specularMap;',\n            '#endif'\n          ].join('\\n');\n\n          var glossinessMapParsFragmentChunk = [\n            '#ifdef USE_GLOSSINESSMAP',\n            '\tuniform sampler2D glossinessMap;',\n            '#endif'\n          ].join('\\n');\n\n          var specularMapFragmentChunk = [\n            'vec3 specularFactor = specular;',\n            '#ifdef USE_SPECULARMAP',\n            '\tvec4 texelSpecular = texture2D( specularMap, vUv );',\n            '\ttexelSpecular = sRGBToLinear( texelSpecular );',\n            '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\n            '\tspecularFactor *= texelSpecular.rgb;',\n            '#endif'\n          ].join('\\n');\n\n          var glossinessMapFragmentChunk = [\n            'float glossinessFactor = glossiness;',\n            '#ifdef USE_GLOSSINESSMAP',\n            '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\n            '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\n            '\tglossinessFactor *= texelGlossiness.a;',\n            '#endif'\n          ].join('\\n');\n\n          var lightPhysicalFragmentChunk = [\n            'PhysicalMaterial material;',\n            'material.diffuseColor = diffuseColor.rgb;',\n            'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );',\n            'material.specularColor = specularFactor.rgb;',\n          ].join('\\n');\n\n          var fragmentShader = shader.fragmentShader\n            .replace('uniform float roughness;', 'uniform vec3 specular;')\n            .replace('uniform float metalness;', 'uniform float glossiness;')\n            .replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk)\n            .replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk)\n            .replace('#include <roughnessmap_fragment>', specularMapFragmentChunk)\n            .replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk)\n            .replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\n\n          delete uniforms.roughness;\n          delete uniforms.metalness;\n          delete uniforms.roughnessMap;\n          delete uniforms.metalnessMap;\n\n          uniforms.specular = { value: new THREE.Color().setHex(0x111111) };\n          uniforms.glossiness = { value: 0.5 };\n          uniforms.specularMap = { value: null };\n          uniforms.glossinessMap = { value: null };\n\n          materialParams.vertexShader = shader.vertexShader;\n          materialParams.fragmentShader = fragmentShader;\n          materialParams.uniforms = uniforms;\n          materialParams.defines = { 'STANDARD': '' }\n\n          materialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n          materialParams.opacity = 1.0;\n\n          var pending = [];\n\n          if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n\n            var array = pbrSpecularGlossiness.diffuseFactor;\n\n            materialParams.color.fromArray(array);\n            materialParams.opacity = array[3];\n\n          }\n\n          if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n\n            pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));\n\n          }\n\n          materialParams.emissive = new THREE.Color(0.0, 0.0, 0.0);\n          materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n          materialParams.specular = new THREE.Color(1.0, 1.0, 1.0);\n\n          if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n\n            materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n\n          }\n\n          if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n\n            var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n            pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));\n            pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));\n\n          }\n\n          return Promise.all(pending);\n\n        },\n\n        createMaterial: function (params) {\n\n          // setup material properties based on MeshStandardMaterial for Specular-Glossiness\n\n          var material = new THREE.ShaderMaterial({\n            defines: params.defines,\n            vertexShader: params.vertexShader,\n            fragmentShader: params.fragmentShader,\n            uniforms: params.uniforms,\n            fog: true,\n            lights: true,\n            opacity: params.opacity,\n            transparent: params.transparent\n          });\n\n          material.isGLTFSpecularGlossinessMaterial = true;\n\n          material.color = params.color;\n\n          material.map = params.map === undefined ? null : params.map;\n\n          material.lightMap = null;\n          material.lightMapIntensity = 1.0;\n\n          material.aoMap = params.aoMap === undefined ? null : params.aoMap;\n          material.aoMapIntensity = 1.0;\n\n          material.emissive = params.emissive;\n          material.emissiveIntensity = 1.0;\n          material.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;\n\n          material.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;\n          material.bumpScale = 1;\n\n          material.normalMap = params.normalMap === undefined ? null : params.normalMap;\n\n          if (params.normalScale) material.normalScale = params.normalScale;\n\n          material.displacementMap = null;\n          material.displacementScale = 1;\n          material.displacementBias = 0;\n\n          material.specularMap = params.specularMap === undefined ? null : params.specularMap;\n          material.specular = params.specular;\n\n          material.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;\n          material.glossiness = params.glossiness;\n\n          material.alphaMap = null;\n\n          material.envMap = params.envMap === undefined ? null : params.envMap;\n          material.envMapIntensity = 1.0;\n\n          material.refractionRatio = 0.98;\n\n          material.extensions.derivatives = true;\n\n          return material;\n\n        },\n\n        /**\n         * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can\n         * copy only properties it knows about or inherits, and misses many properties that would\n         * normally be defined by MeshStandardMaterial.\n         *\n         * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of\n         * loading a glTF model, but cloning later (e.g. by the user) would require these changes\n         * AND also updating `.onBeforeRender` on the parent mesh.\n         *\n         * @param  {THREE.ShaderMaterial} source\n         * @return {THREE.ShaderMaterial}\n         */\n        cloneMaterial: function (source) {\n\n          var target = source.clone();\n\n          target.isGLTFSpecularGlossinessMaterial = true;\n\n          var params = this.specularGlossinessParams;\n\n          for (var i = 0, il = params.length; i < il; i++) {\n\n            var value = source[params[i]];\n            target[params[i]] = (value && value.isColor) ? value.clone() : value;\n\n          }\n\n          return target;\n\n        },\n\n        // Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.\n        refreshUniforms: function (renderer, scene, camera, geometry, material) {\n\n          if (material.isGLTFSpecularGlossinessMaterial !== true) {\n\n            return;\n\n          }\n\n          var uniforms = material.uniforms;\n          var defines = material.defines;\n\n          uniforms.opacity.value = material.opacity;\n\n          uniforms.diffuse.value.copy(material.color);\n          uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n\n          uniforms.map.value = material.map;\n          uniforms.specularMap.value = material.specularMap;\n          uniforms.alphaMap.value = material.alphaMap;\n\n          uniforms.lightMap.value = material.lightMap;\n          uniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n          uniforms.aoMap.value = material.aoMap;\n          uniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n          // uv repeat and offset setting priorities\n          // 1. color map\n          // 2. specular map\n          // 3. normal map\n          // 4. bump map\n          // 5. alpha map\n          // 6. emissive map\n\n          var uvScaleMap;\n\n          if (material.map) {\n\n            uvScaleMap = material.map;\n\n          } else if (material.specularMap) {\n\n            uvScaleMap = material.specularMap;\n\n          } else if (material.displacementMap) {\n\n            uvScaleMap = material.displacementMap;\n\n          } else if (material.normalMap) {\n\n            uvScaleMap = material.normalMap;\n\n          } else if (material.bumpMap) {\n\n            uvScaleMap = material.bumpMap;\n\n          } else if (material.glossinessMap) {\n\n            uvScaleMap = material.glossinessMap;\n\n          } else if (material.alphaMap) {\n\n            uvScaleMap = material.alphaMap;\n\n          } else if (material.emissiveMap) {\n\n            uvScaleMap = material.emissiveMap;\n\n          }\n\n          if (uvScaleMap !== undefined) {\n\n            // backwards compatibility\n            if (uvScaleMap.isWebGLRenderTarget) {\n\n              uvScaleMap = uvScaleMap.texture;\n\n            }\n\n            if (uvScaleMap.matrixAutoUpdate === true) {\n\n              uvScaleMap.updateMatrix();\n\n            }\n\n            uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n\n          }\n\n          if (material.envMap) {\n\n            uniforms.envMap.value = material.envMap;\n            uniforms.envMapIntensity.value = material.envMapIntensity;\n\n            // don't flip CubeTexture envMaps, flip everything else:\n            //  WebGLRenderTargetCube will be flipped for backwards compatibility\n            //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n            // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n            uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1;\n\n            uniforms.reflectivity.value = material.reflectivity;\n            uniforms.refractionRatio.value = material.refractionRatio;\n\n            uniforms.maxMipLevel.value = renderer.properties.get(material.envMap).__maxMipLevel;\n\n          }\n\n          uniforms.specular.value.copy(material.specular);\n          uniforms.glossiness.value = material.glossiness;\n\n          uniforms.glossinessMap.value = material.glossinessMap;\n\n          uniforms.emissiveMap.value = material.emissiveMap;\n          uniforms.bumpMap.value = material.bumpMap;\n          uniforms.normalMap.value = material.normalMap;\n\n          uniforms.displacementMap.value = material.displacementMap;\n          uniforms.displacementScale.value = material.displacementScale;\n          uniforms.displacementBias.value = material.displacementBias;\n\n          if (uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined) {\n\n            defines.USE_GLOSSINESSMAP = '';\n            // set USE_ROUGHNESSMAP to enable vUv\n            defines.USE_ROUGHNESSMAP = '';\n\n          }\n\n          if (uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined) {\n\n            delete defines.USE_GLOSSINESSMAP;\n            delete defines.USE_ROUGHNESSMAP;\n\n          }\n\n        }\n\n      };\n\n    }\n\n    /*********************************/\n    /********** INTERPOLATION ********/\n    /*********************************/\n\n    // Spline Interpolation\n    // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n    function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\n      THREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n\n    }\n\n    GLTFCubicSplineInterpolant.prototype = Object.create(THREE.Interpolant.prototype);\n    GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n    GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function (index) {\n\n      // Copies a sample value to the result buffer. See description of glTF\n      // CUBICSPLINE values layout in interpolate_() function below.\n\n      var result = this.resultBuffer,\n        values = this.sampleValues,\n        valueSize = this.valueSize,\n        offset = index * valueSize * 3 + valueSize;\n\n      for (var i = 0; i !== valueSize; i++) {\n\n        result[i] = values[offset + i];\n\n      }\n\n      return result;\n\n    };\n\n    GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n    GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n    GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\n\n      var result = this.resultBuffer;\n      var values = this.sampleValues;\n      var stride = this.valueSize;\n\n      var stride2 = stride * 2;\n      var stride3 = stride * 3;\n\n      var td = t1 - t0;\n\n      var p = (t - t0) / td;\n      var pp = p * p;\n      var ppp = pp * p;\n\n      var offset1 = i1 * stride3;\n      var offset0 = offset1 - stride3;\n\n      var s2 = - 2 * ppp + 3 * pp;\n      var s3 = ppp - pp;\n      var s0 = 1 - s2;\n      var s1 = s3 - pp + p;\n\n      // Layout of keyframe output values for CUBICSPLINE animations:\n      //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n      for (var i = 0; i !== stride; i++) {\n\n        var p0 = values[offset0 + i + stride]; // splineVertex_k\n        var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\n        var p1 = values[offset1 + i + stride]; // splineVertex_k+1\n        var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n        result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n      }\n\n      return result;\n\n    };\n\n    /*********************************/\n    /********** INTERNALS ************/\n    /*********************************/\n\n    /* CONSTANTS */\n\n    var WEBGL_CONSTANTS = {\n      FLOAT: 5126,\n      //FLOAT_MAT2: 35674,\n      FLOAT_MAT3: 35675,\n      FLOAT_MAT4: 35676,\n      FLOAT_VEC2: 35664,\n      FLOAT_VEC3: 35665,\n      FLOAT_VEC4: 35666,\n      LINEAR: 9729,\n      REPEAT: 10497,\n      SAMPLER_2D: 35678,\n      POINTS: 0,\n      LINES: 1,\n      LINE_LOOP: 2,\n      LINE_STRIP: 3,\n      TRIANGLES: 4,\n      TRIANGLE_STRIP: 5,\n      TRIANGLE_FAN: 6,\n      UNSIGNED_BYTE: 5121,\n      UNSIGNED_SHORT: 5123\n    };\n\n    var WEBGL_COMPONENT_TYPES = {\n      5120: Int8Array,\n      5121: Uint8Array,\n      5122: Int16Array,\n      5123: Uint16Array,\n      5125: Uint32Array,\n      5126: Float32Array\n    };\n\n    var WEBGL_FILTERS = {\n      9728: THREE.NearestFilter,\n      9729: THREE.LinearFilter,\n      9984: THREE.NearestMipmapNearestFilter,\n      9985: THREE.LinearMipmapNearestFilter,\n      9986: THREE.NearestMipmapLinearFilter,\n      9987: THREE.LinearMipmapLinearFilter\n    };\n\n    var WEBGL_WRAPPINGS = {\n      33071: THREE.ClampToEdgeWrapping,\n      33648: THREE.MirroredRepeatWrapping,\n      10497: THREE.RepeatWrapping\n    };\n\n    var WEBGL_TYPE_SIZES = {\n      'SCALAR': 1,\n      'VEC2': 2,\n      'VEC3': 3,\n      'VEC4': 4,\n      'MAT2': 4,\n      'MAT3': 9,\n      'MAT4': 16\n    };\n\n    var ATTRIBUTES = {\n      POSITION: 'position',\n      NORMAL: 'normal',\n      TANGENT: 'tangent',\n      TEXCOORD_0: 'uv',\n      TEXCOORD_1: 'uv2',\n      COLOR_0: 'color',\n      WEIGHTS_0: 'skinWeight',\n      JOINTS_0: 'skinIndex',\n    };\n\n    var PATH_PROPERTIES = {\n      scale: 'scale',\n      translation: 'position',\n      rotation: 'quaternion',\n      weights: 'morphTargetInfluences'\n    };\n\n    var INTERPOLATION = {\n      CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n      // keyframe track will be initialized with a default interpolation type, then modified.\n      LINEAR: THREE.InterpolateLinear,\n      STEP: THREE.InterpolateDiscrete\n    };\n\n    var ALPHA_MODES = {\n      OPAQUE: 'OPAQUE',\n      MASK: 'MASK',\n      BLEND: 'BLEND'\n    };\n\n    var MIME_TYPE_FORMATS = {\n      'image/png': THREE.RGBAFormat,\n      'image/jpeg': THREE.RGBFormat\n    };\n\n    /* UTILITY FUNCTIONS */\n\n    function resolveURL(url, path) {\n\n      // Invalid URL\n      if (typeof url !== 'string' || url === '') return '';\n\n      // Host Relative URL\n      if (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\n\n        path = path.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n\n      }\n\n      // Absolute URL http://,https://,//\n      if (/^(https?:)?\\/\\//i.test(url)) return url;\n\n      // Data URI\n      if (/^data:.*,.*$/i.test(url)) return url;\n\n      // Blob URL\n      if (/^blob:.*$/i.test(url)) return url;\n\n      // Relative URL\n      return path + url;\n\n    }\n\n    var defaultMaterial;\n\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n     */\n    function createDefaultMaterial() {\n\n      defaultMaterial = defaultMaterial || new THREE.MeshStandardMaterial({\n        color: 0xFFFFFF,\n        emissive: 0x000000,\n        metalness: 1,\n        roughness: 1,\n        transparent: false,\n        depthTest: true,\n        side: THREE.FrontSide\n      });\n\n      return defaultMaterial;\n\n    }\n\n    function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n\n      // Add unknown glTF extensions to an object's userData.\n\n      for (var name in objectDef.extensions) {\n\n        if (knownExtensions[name] === undefined) {\n\n          object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n          object.userData.gltfExtensions[name] = objectDef.extensions[name];\n\n        }\n\n      }\n\n    }\n\n    /**\n     * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry} object\n     * @param {GLTF.definition} gltfDef\n     */\n    function assignExtrasToUserData(object, gltfDef) {\n\n      if (gltfDef.extras !== undefined) {\n\n        if (typeof gltfDef.extras === 'object') {\n\n          Object.assign(object.userData, gltfDef.extras);\n\n        } else {\n\n          console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);\n\n        }\n\n      }\n\n    }\n\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n     *\n     * @param {THREE.BufferGeometry} geometry\n     * @param {Array<GLTF.Target>} targets\n     * @param {GLTFParser} parser\n     * @return {Promise<THREE.BufferGeometry>}\n     */\n    function addMorphTargets(geometry, targets, parser) {\n\n      var hasMorphPosition = false;\n      var hasMorphNormal = false;\n\n      for (var i = 0, il = targets.length; i < il; i++) {\n\n        var target = targets[i];\n\n        if (target.POSITION !== undefined) hasMorphPosition = true;\n        if (target.NORMAL !== undefined) hasMorphNormal = true;\n\n        if (hasMorphPosition && hasMorphNormal) break;\n\n      }\n\n      if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);\n\n      var pendingPositionAccessors = [];\n      var pendingNormalAccessors = [];\n\n      for (var i = 0, il = targets.length; i < il; i++) {\n\n        var target = targets[i];\n\n        if (hasMorphPosition) {\n\n          var pendingAccessor = target.POSITION !== undefined\n            ? parser.getDependency('accessor', target.POSITION)\n            : geometry.attributes.position;\n\n          pendingPositionAccessors.push(pendingAccessor);\n\n        }\n\n        if (hasMorphNormal) {\n\n          var pendingAccessor = target.NORMAL !== undefined\n            ? parser.getDependency('accessor', target.NORMAL)\n            : geometry.attributes.normal;\n\n          pendingNormalAccessors.push(pendingAccessor);\n\n        }\n\n      }\n\n      return Promise.all([\n        Promise.all(pendingPositionAccessors),\n        Promise.all(pendingNormalAccessors)\n      ]).then(function (accessors) {\n\n        var morphPositions = accessors[0];\n        var morphNormals = accessors[1];\n\n        // Clone morph target accessors before modifying them.\n\n        for (var i = 0, il = morphPositions.length; i < il; i++) {\n\n          if (geometry.attributes.position === morphPositions[i]) continue;\n\n          morphPositions[i] = cloneBufferAttribute(morphPositions[i]);\n\n        }\n\n        for (var i = 0, il = morphNormals.length; i < il; i++) {\n\n          if (geometry.attributes.normal === morphNormals[i]) continue;\n\n          morphNormals[i] = cloneBufferAttribute(morphNormals[i]);\n\n        }\n\n        for (var i = 0, il = targets.length; i < il; i++) {\n\n          var target = targets[i];\n          var attributeName = 'morphTarget' + i;\n\n          if (hasMorphPosition) {\n\n            // Three.js morph position is absolute value. The formula is\n            //   basePosition\n            //     + weight0 * ( morphPosition0 - basePosition )\n            //     + weight1 * ( morphPosition1 - basePosition )\n            //     ...\n            // while the glTF one is relative\n            //   basePosition\n            //     + weight0 * glTFmorphPosition0\n            //     + weight1 * glTFmorphPosition1\n            //     ...\n            // then we need to convert from relative to absolute here.\n\n            if (target.POSITION !== undefined) {\n\n              var positionAttribute = morphPositions[i];\n              positionAttribute.name = attributeName;\n\n              var position = geometry.attributes.position;\n\n              for (var j = 0, jl = positionAttribute.count; j < jl; j++) {\n\n                positionAttribute.setXYZ(\n                  j,\n                  positionAttribute.getX(j) + position.getX(j),\n                  positionAttribute.getY(j) + position.getY(j),\n                  positionAttribute.getZ(j) + position.getZ(j)\n                );\n\n              }\n\n            }\n\n          }\n\n          if (hasMorphNormal) {\n\n            // see target.POSITION's comment\n\n            if (target.NORMAL !== undefined) {\n\n              var normalAttribute = morphNormals[i];\n              normalAttribute.name = attributeName;\n\n              var normal = geometry.attributes.normal;\n\n              for (var j = 0, jl = normalAttribute.count; j < jl; j++) {\n\n                normalAttribute.setXYZ(\n                  j,\n                  normalAttribute.getX(j) + normal.getX(j),\n                  normalAttribute.getY(j) + normal.getY(j),\n                  normalAttribute.getZ(j) + normal.getZ(j)\n                );\n\n              }\n\n            }\n\n          }\n\n        }\n\n        if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n        if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n\n        return geometry;\n\n      });\n\n    }\n\n    /**\n     * @param {THREE.Mesh} mesh\n     * @param {GLTF.Mesh} meshDef\n     */\n    function updateMorphTargets(mesh, meshDef) {\n\n      mesh.updateMorphTargets();\n\n      if (meshDef.weights !== undefined) {\n\n        for (var i = 0, il = meshDef.weights.length; i < il; i++) {\n\n          mesh.morphTargetInfluences[i] = meshDef.weights[i];\n\n        }\n\n      }\n\n      // .extras has user-defined data, so check that .extras.targetNames is an array.\n      if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n\n        var targetNames = meshDef.extras.targetNames;\n\n        if (mesh.morphTargetInfluences.length === targetNames.length) {\n\n          mesh.morphTargetDictionary = {};\n\n          for (var i = 0, il = targetNames.length; i < il; i++) {\n\n            mesh.morphTargetDictionary[targetNames[i]] = i;\n\n          }\n\n        } else {\n\n          console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\n\n        }\n\n      }\n\n    }\n\n    function createPrimitiveKey(primitiveDef) {\n\n      var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n      var geometryKey;\n\n      if (dracoExtension) {\n\n        geometryKey = 'draco:' + dracoExtension.bufferView\n          + ':' + dracoExtension.indices\n          + ':' + createAttributesKey(dracoExtension.attributes);\n\n      } else {\n\n        geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;\n\n      }\n\n      return geometryKey;\n\n    }\n\n    function createAttributesKey(attributes) {\n\n      var attributesKey = '';\n\n      var keys = Object.keys(attributes).sort();\n\n      for (var i = 0, il = keys.length; i < il; i++) {\n\n        attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';\n\n      }\n\n      return attributesKey;\n\n    }\n\n    function cloneBufferAttribute(attribute) {\n\n      if (attribute.isInterleavedBufferAttribute) {\n\n        var count = attribute.count;\n        var itemSize = attribute.itemSize;\n        var array = attribute.array.slice(0, count * itemSize);\n\n        for (var i = 0, j = 0; i < count; ++i) {\n\n          array[j++] = attribute.getX(i);\n          if (itemSize >= 2) array[j++] = attribute.getY(i);\n          if (itemSize >= 3) array[j++] = attribute.getZ(i);\n          if (itemSize >= 4) array[j++] = attribute.getW(i);\n\n        }\n\n        return new THREE.BufferAttribute(array, itemSize, attribute.normalized);\n\n      }\n\n      return attribute.clone();\n\n    }\n\n    /* GLTF PARSER */\n\n    function GLTFParser(json, extensions, options) {\n\n      this.json = json || {};\n      this.extensions = extensions || {};\n      this.options = options || {};\n\n      // loader object cache\n      this.cache = new GLTFRegistry();\n\n      // BufferGeometry caching\n      this.primitiveCache = {};\n\n      this.textureLoader = new THREE.TextureLoader(this.options.manager);\n      this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n\n      this.fileLoader = new THREE.FileLoader(this.options.manager);\n      this.fileLoader.setResponseType('arraybuffer');\n\n      if (this.options.crossOrigin === 'use-credentials') {\n\n        this.fileLoader.setWithCredentials(true);\n\n      }\n\n    }\n\n    GLTFParser.prototype.parse = function (onLoad, onError) {\n\n      var parser = this;\n      var json = this.json;\n      var extensions = this.extensions;\n\n      // Clear the loader cache\n      this.cache.removeAll();\n\n      // Mark the special nodes/meshes in json for efficient parse\n      this.markDefs();\n\n      Promise.all([\n\n        this.getDependencies('scene'),\n        this.getDependencies('animation'),\n        this.getDependencies('camera'),\n\n      ]).then(function (dependencies) {\n\n        var result = {\n          scene: dependencies[0][json.scene || 0],\n          scenes: dependencies[0],\n          animations: dependencies[1],\n          cameras: dependencies[2],\n          asset: json.asset,\n          parser: parser,\n          userData: {}\n        };\n\n        addUnknownExtensionsToUserData(extensions, result, json);\n\n        assignExtrasToUserData(result, json);\n\n        onLoad(result);\n\n      }).catch(onError);\n\n    };\n\n    /**\n     * Marks the special nodes/meshes in json for efficient parse.\n     */\n    GLTFParser.prototype.markDefs = function () {\n\n      var nodeDefs = this.json.nodes || [];\n      var skinDefs = this.json.skins || [];\n      var meshDefs = this.json.meshes || [];\n\n      var meshReferences = {};\n      var meshUses = {};\n\n      // Nothing in the node definition indicates whether it is a Bone or an\n      // Object3D. Use the skins' joint references to mark bones.\n      for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n\n        var joints = skinDefs[skinIndex].joints;\n\n        for (var i = 0, il = joints.length; i < il; i++) {\n\n          nodeDefs[joints[i]].isBone = true;\n\n        }\n\n      }\n\n      // Meshes can (and should) be reused by multiple nodes in a glTF asset. To\n      // avoid having more than one THREE.Mesh with the same name, count\n      // references and rename instances below.\n      //\n      // Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n      for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n\n        var nodeDef = nodeDefs[nodeIndex];\n\n        if (nodeDef.mesh !== undefined) {\n\n          if (meshReferences[nodeDef.mesh] === undefined) {\n\n            meshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;\n\n          }\n\n          meshReferences[nodeDef.mesh]++;\n\n          // Nothing in the mesh definition indicates whether it is\n          // a SkinnedMesh or Mesh. Use the node's mesh reference\n          // to mark SkinnedMesh if node has skin.\n          if (nodeDef.skin !== undefined) {\n\n            meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n\n          }\n\n        }\n\n      }\n\n      this.json.meshReferences = meshReferences;\n      this.json.meshUses = meshUses;\n\n    };\n\n    /**\n     * Requests the specified dependency asynchronously, with caching.\n     * @param {string} type\n     * @param {number} index\n     * @return {Promise<THREE.Object3D|THREE.Material|THREE.Texture|THREE.AnimationClip|ArrayBuffer|Object>}\n     */\n    GLTFParser.prototype.getDependency = function (type, index) {\n\n      var cacheKey = type + ':' + index;\n      var dependency = this.cache.get(cacheKey);\n\n      if (!dependency) {\n\n        switch (type) {\n\n          case 'scene':\n            dependency = this.loadScene(index);\n            break;\n\n          case 'node':\n            dependency = this.loadNode(index);\n            break;\n\n          case 'mesh':\n            dependency = this.loadMesh(index);\n            break;\n\n          case 'accessor':\n            dependency = this.loadAccessor(index);\n            break;\n\n          case 'bufferView':\n            dependency = this.loadBufferView(index);\n            break;\n\n          case 'buffer':\n            dependency = this.loadBuffer(index);\n            break;\n\n          case 'material':\n            dependency = this.loadMaterial(index);\n            break;\n\n          case 'texture':\n            dependency = this.loadTexture(index);\n            break;\n\n          case 'skin':\n            dependency = this.loadSkin(index);\n            break;\n\n          case 'animation':\n            dependency = this.loadAnimation(index);\n            break;\n\n          case 'camera':\n            dependency = this.loadCamera(index);\n            break;\n\n          case 'light':\n            dependency = this.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].loadLight(index);\n            break;\n\n          default:\n            throw new Error('Unknown type: ' + type);\n\n        }\n\n        this.cache.add(cacheKey, dependency);\n\n      }\n\n      return dependency;\n\n    };\n\n    /**\n     * Requests all dependencies of the specified type asynchronously, with caching.\n     * @param {string} type\n     * @return {Promise<Array<Object>>}\n     */\n    GLTFParser.prototype.getDependencies = function (type) {\n\n      var dependencies = this.cache.get(type);\n\n      if (!dependencies) {\n\n        var parser = this;\n        var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n\n        dependencies = Promise.all(defs.map(function (def, index) {\n\n          return parser.getDependency(type, index);\n\n        }));\n\n        this.cache.add(type, dependencies);\n\n      }\n\n      return dependencies;\n\n    };\n\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n     * @param {number} bufferIndex\n     * @return {Promise<ArrayBuffer>}\n     */\n    GLTFParser.prototype.loadBuffer = function (bufferIndex) {\n\n      var bufferDef = this.json.buffers[bufferIndex];\n      var loader = this.fileLoader;\n\n      if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n\n        throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\n\n      }\n\n      // If present, GLB container is required to be the first buffer.\n      if (bufferDef.uri === undefined && bufferIndex === 0) {\n\n        return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n\n      }\n\n      var options = this.options;\n\n      return new Promise(function (resolve, reject) {\n\n        loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n\n          reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n\n        });\n\n      });\n\n    };\n\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n     * @param {number} bufferViewIndex\n     * @return {Promise<ArrayBuffer>}\n     */\n    GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {\n\n      var bufferViewDef = this.json.bufferViews[bufferViewIndex];\n\n      return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n\n        var byteLength = bufferViewDef.byteLength || 0;\n        var byteOffset = bufferViewDef.byteOffset || 0;\n        return buffer.slice(byteOffset, byteOffset + byteLength);\n\n      });\n\n    };\n\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n     * @param {number} accessorIndex\n     * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}\n     */\n    GLTFParser.prototype.loadAccessor = function (accessorIndex) {\n\n      var parser = this;\n      var json = this.json;\n\n      var accessorDef = this.json.accessors[accessorIndex];\n\n      if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n\n        // Ignore empty accessors, which may be used to declare runtime\n        // information about attributes coming from another source (e.g. Draco\n        // compression extension).\n        return Promise.resolve(null);\n\n      }\n\n      var pendingBufferViews = [];\n\n      if (accessorDef.bufferView !== undefined) {\n\n        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\n\n      } else {\n\n        pendingBufferViews.push(null);\n\n      }\n\n      if (accessorDef.sparse !== undefined) {\n\n        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\n        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\n\n      }\n\n      return Promise.all(pendingBufferViews).then(function (bufferViews) {\n\n        var bufferView = bufferViews[0];\n\n        var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n        var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n\n        // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n        var elementBytes = TypedArray.BYTES_PER_ELEMENT;\n        var itemBytes = elementBytes * itemSize;\n        var byteOffset = accessorDef.byteOffset || 0;\n        var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;\n        var normalized = accessorDef.normalized === true;\n        var array, bufferAttribute;\n\n        // The buffer is not interleaved if the stride is the item size in bytes.\n        if (byteStride && byteStride !== itemBytes) {\n\n          // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n          // This makes sure that IBA.count reflects accessor.count properly\n          var ibSlice = Math.floor(byteOffset / byteStride);\n          var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n          var ib = parser.cache.get(ibCacheKey);\n\n          if (!ib) {\n\n            array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n\n            // Integer parameters to IB/IBA are in array elements, not bytes.\n            ib = new THREE.InterleavedBuffer(array, byteStride / elementBytes);\n\n            parser.cache.add(ibCacheKey, ib);\n\n          }\n\n          bufferAttribute = new THREE.InterleavedBufferAttribute(ib, itemSize, (byteOffset % byteStride) / elementBytes, normalized);\n\n        } else {\n\n          if (bufferView === null) {\n\n            array = new TypedArray(accessorDef.count * itemSize);\n\n          } else {\n\n            array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n\n          }\n\n          bufferAttribute = new THREE.BufferAttribute(array, itemSize, normalized);\n\n        }\n\n        // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n        if (accessorDef.sparse !== undefined) {\n\n          var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n          var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n\n          var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n          var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n          var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n          var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n\n          if (bufferView !== null) {\n\n            // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n            bufferAttribute.setArray(bufferAttribute.array.slice());\n\n          }\n\n          for (var i = 0, il = sparseIndices.length; i < il; i++) {\n\n            var index = sparseIndices[i];\n\n            bufferAttribute.setX(index, sparseValues[i * itemSize]);\n            if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n            if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n            if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n            if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\n\n          }\n\n        }\n\n        return bufferAttribute;\n\n      });\n\n    };\n\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n     * @param {number} textureIndex\n     * @return {Promise<THREE.Texture>}\n     */\n    GLTFParser.prototype.loadTexture = function (textureIndex) {\n\n      var parser = this;\n      var json = this.json;\n      var options = this.options;\n      var textureLoader = this.textureLoader;\n\n      var URL = window.URL || window.webkitURL;\n\n      var textureDef = json.textures[textureIndex];\n\n      var textureExtensions = textureDef.extensions || {};\n\n      var source;\n\n      if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {\n\n        source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];\n\n      } else {\n\n        source = json.images[textureDef.source];\n\n      }\n\n      var sourceURI = source.uri;\n      var isObjectURL = false;\n\n      if (source.bufferView !== undefined) {\n\n        // Load binary image data from bufferView, if provided.\n\n        sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\n\n          isObjectURL = true;\n          var blob = new Blob([bufferView], { type: source.mimeType });\n          sourceURI = URL.createObjectURL(blob);\n          return sourceURI;\n\n        });\n\n      }\n\n      return Promise.resolve(sourceURI).then(function (sourceURI) {\n\n        // Load Texture resource.\n\n        var loader = THREE.Loader.Handlers.get(sourceURI);\n\n        if (!loader) {\n\n          loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]\n            ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader\n            : textureLoader;\n\n        }\n\n        return new Promise(function (resolve, reject) {\n\n          loader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);\n\n        });\n\n      }).then(function (texture) {\n\n        // Clean up resources and configure Texture.\n\n        if (isObjectURL === true) {\n\n          URL.revokeObjectURL(sourceURI);\n\n        }\n\n        texture.flipY = false;\n\n        if (textureDef.name !== undefined) texture.name = textureDef.name;\n\n        // Ignore unknown mime types, like DDS files.\n        if (source.mimeType in MIME_TYPE_FORMATS) {\n\n          texture.format = MIME_TYPE_FORMATS[source.mimeType];\n\n        }\n\n        var samplers = json.samplers || {};\n        var sampler = samplers[textureDef.sampler] || {};\n\n        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;\n        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.LinearMipmapLinearFilter;\n        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;\n        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;\n\n        return texture;\n\n      });\n\n    };\n\n    /**\n     * Asynchronously assigns a texture to the given material parameters.\n     * @param {Object} materialParams\n     * @param {string} mapName\n     * @param {Object} mapDef\n     * @return {Promise}\n     */\n    GLTFParser.prototype.assignTexture = function (materialParams, mapName, mapDef) {\n\n      var parser = this;\n\n      return this.getDependency('texture', mapDef.index).then(function (texture) {\n\n        if (!texture.isCompressedTexture) {\n\n          switch (mapName) {\n\n            case 'aoMap':\n            case 'emissiveMap':\n            case 'metalnessMap':\n            case 'normalMap':\n            case 'roughnessMap':\n              texture.format = THREE.RGBFormat;\n              break;\n\n          }\n\n        }\n\n        if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n\n          var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;\n\n          if (transform) {\n\n            texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n\n          }\n\n        }\n\n        materialParams[mapName] = texture;\n\n      });\n\n    };\n\n    /**\n     * Assigns final material to a Mesh, Line, or Points instance. The instance\n     * already has a material (generated from the glTF material options alone)\n     * but reuse of the same glTF material may require multiple threejs materials\n     * to accomodate different primitive types, defines, etc. New materials will\n     * be created if necessary, and reused from a cache.\n     * @param  {THREE.Object3D} mesh Mesh, Line, or Points instance.\n     */\n    GLTFParser.prototype.assignFinalMaterial = function (mesh) {\n\n      var geometry = mesh.geometry;\n      var material = mesh.material;\n      var extensions = this.extensions;\n\n      var useVertexTangents = geometry.attributes.tangent !== undefined;\n      var useVertexColors = geometry.attributes.color !== undefined;\n      var useFlatShading = geometry.attributes.normal === undefined;\n      var useSkinning = mesh.isSkinnedMesh === true;\n      var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;\n      var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n\n      if (mesh.isPoints) {\n\n        var cacheKey = 'PointsMaterial:' + material.uuid;\n\n        var pointsMaterial = this.cache.get(cacheKey);\n\n        if (!pointsMaterial) {\n\n          pointsMaterial = new THREE.PointsMaterial();\n          THREE.Material.prototype.copy.call(pointsMaterial, material);\n          pointsMaterial.color.copy(material.color);\n          pointsMaterial.map = material.map;\n          pointsMaterial.lights = false; // PointsMaterial doesn't support lights yet\n          pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n          this.cache.add(cacheKey, pointsMaterial);\n\n        }\n\n        material = pointsMaterial;\n\n      } else if (mesh.isLine) {\n\n        var cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n        var lineMaterial = this.cache.get(cacheKey);\n\n        if (!lineMaterial) {\n\n          lineMaterial = new THREE.LineBasicMaterial();\n          THREE.Material.prototype.copy.call(lineMaterial, material);\n          lineMaterial.color.copy(material.color);\n          lineMaterial.lights = false; // LineBasicMaterial doesn't support lights yet\n\n          this.cache.add(cacheKey, lineMaterial);\n\n        }\n\n        material = lineMaterial;\n\n      }\n\n      // Clone the material if it will be modified\n      if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {\n\n        var cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n        if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';\n        if (useSkinning) cacheKey += 'skinning:';\n        if (useVertexTangents) cacheKey += 'vertex-tangents:';\n        if (useVertexColors) cacheKey += 'vertex-colors:';\n        if (useFlatShading) cacheKey += 'flat-shading:';\n        if (useMorphTargets) cacheKey += 'morph-targets:';\n        if (useMorphNormals) cacheKey += 'morph-normals:';\n\n        var cachedMaterial = this.cache.get(cacheKey);\n\n        if (!cachedMaterial) {\n\n          cachedMaterial = material.isGLTFSpecularGlossinessMaterial\n            ? extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].cloneMaterial(material)\n            : material.clone();\n\n          if (useSkinning) cachedMaterial.skinning = true;\n          if (useVertexTangents) cachedMaterial.vertexTangents = true;\n          if (useVertexColors) cachedMaterial.vertexColors = THREE.VertexColors;\n          if (useFlatShading) cachedMaterial.flatShading = true;\n          if (useMorphTargets) cachedMaterial.morphTargets = true;\n          if (useMorphNormals) cachedMaterial.morphNormals = true;\n\n          this.cache.add(cacheKey, cachedMaterial);\n\n        }\n\n        material = cachedMaterial;\n\n      }\n\n      // workarounds for mesh and geometry\n\n      if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\n\n        console.log('THREE.GLTFLoader: Duplicating UVs to support aoMap.');\n        geometry.addAttribute('uv2', new THREE.BufferAttribute(geometry.attributes.uv.array, 2));\n\n      }\n\n      if (material.isGLTFSpecularGlossinessMaterial) {\n\n        // for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update\n        mesh.onBeforeRender = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms;\n\n      }\n\n      mesh.material = material;\n\n    };\n\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n     * @param {number} materialIndex\n     * @return {Promise<THREE.Material>}\n     */\n    GLTFParser.prototype.loadMaterial = function (materialIndex) {\n\n      var parser = this;\n      var json = this.json;\n      var extensions = this.extensions;\n      var materialDef = json.materials[materialIndex];\n\n      var materialType;\n      var materialParams = {};\n      var materialExtensions = materialDef.extensions || {};\n\n      var pending = [];\n\n      if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n\n        var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n        materialType = sgExtension.getMaterialType();\n        pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n\n      } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n\n        var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n        materialType = kmuExtension.getMaterialType();\n        pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n\n      } else {\n\n        // Specification:\n        // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n        materialType = THREE.MeshStandardMaterial;\n\n        var metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n        materialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n        materialParams.opacity = 1.0;\n\n        if (Array.isArray(metallicRoughness.baseColorFactor)) {\n\n          var array = metallicRoughness.baseColorFactor;\n\n          materialParams.color.fromArray(array);\n          materialParams.opacity = array[3];\n\n        }\n\n        if (metallicRoughness.baseColorTexture !== undefined) {\n\n          pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n\n        }\n\n        materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n        materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n        if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n\n          pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));\n          pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));\n\n        }\n\n      }\n\n      if (materialDef.doubleSided === true) {\n\n        materialParams.side = THREE.DoubleSide;\n\n      }\n\n      var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n      if (alphaMode === ALPHA_MODES.BLEND) {\n\n        materialParams.transparent = true;\n\n      } else {\n\n        materialParams.transparent = false;\n\n        if (alphaMode === ALPHA_MODES.MASK) {\n\n          materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n        }\n\n      }\n\n      if (materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n\n        pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));\n\n        materialParams.normalScale = new THREE.Vector2(1, 1);\n\n        if (materialDef.normalTexture.scale !== undefined) {\n\n          materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);\n\n        }\n\n      }\n\n      if (materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n\n        pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));\n\n        if (materialDef.occlusionTexture.strength !== undefined) {\n\n          materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n        }\n\n      }\n\n      if (materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial) {\n\n        materialParams.emissive = new THREE.Color().fromArray(materialDef.emissiveFactor);\n\n      }\n\n      if (materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n\n        pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));\n\n      }\n\n      return Promise.all(pending).then(function () {\n\n        var material;\n\n        if (materialType === THREE.ShaderMaterial) {\n\n          material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n\n        } else {\n\n          material = new materialType(materialParams);\n\n        }\n\n        if (materialDef.name !== undefined) material.name = materialDef.name;\n\n        // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n        if (material.map) material.map.encoding = THREE.sRGBEncoding;\n        if (material.emissiveMap) material.emissiveMap.encoding = THREE.sRGBEncoding;\n        if (material.specularMap) material.specularMap.encoding = THREE.sRGBEncoding;\n\n        assignExtrasToUserData(material, materialDef);\n\n        if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n\n        return material;\n\n      });\n\n    };\n\n    /**\n     * @param {THREE.BufferGeometry} geometry\n     * @param {GLTF.Primitive} primitiveDef\n     * @param {GLTFParser} parser\n     * @return {Promise<THREE.BufferGeometry>}\n     */\n    function addPrimitiveAttributes(geometry, primitiveDef, parser) {\n\n      var attributes = primitiveDef.attributes;\n\n      var pending = [];\n\n      function assignAttributeAccessor(accessorIndex, attributeName) {\n\n        return parser.getDependency('accessor', accessorIndex)\n          .then(function (accessor) {\n\n            geometry.addAttribute(attributeName, accessor);\n\n          });\n\n      }\n\n      for (var gltfAttributeName in attributes) {\n\n        var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n\n        // Skip attributes already provided by e.g. Draco extension.\n        if (threeAttributeName in geometry.attributes) continue;\n\n        pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n\n      }\n\n      if (primitiveDef.indices !== undefined && !geometry.index) {\n\n        var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n\n          geometry.setIndex(accessor);\n\n        });\n\n        pending.push(accessor);\n\n      }\n\n      assignExtrasToUserData(geometry, primitiveDef);\n\n      return Promise.all(pending).then(function () {\n\n        return primitiveDef.targets !== undefined\n          ? addMorphTargets(geometry, primitiveDef.targets, parser)\n          : geometry;\n\n      });\n\n    }\n\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n     *\n     * Creates BufferGeometries from primitives.\n     *\n     * @param {Array<GLTF.Primitive>} primitives\n     * @return {Promise<Array<THREE.BufferGeometry>>}\n     */\n    GLTFParser.prototype.loadGeometries = function (primitives) {\n\n      var parser = this;\n      var extensions = this.extensions;\n      var cache = this.primitiveCache;\n\n      function createDracoPrimitive(primitive) {\n\n        return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n          .decodePrimitive(primitive, parser)\n          .then(function (geometry) {\n\n            return addPrimitiveAttributes(geometry, primitive, parser);\n\n          });\n\n      }\n\n      var pending = [];\n\n      for (var i = 0, il = primitives.length; i < il; i++) {\n\n        var primitive = primitives[i];\n        var cacheKey = createPrimitiveKey(primitive);\n\n        // See if we've already created this geometry\n        var cached = cache[cacheKey];\n\n        if (cached) {\n\n          // Use the cached geometry if it exists\n          pending.push(cached.promise);\n\n        } else {\n\n          var geometryPromise;\n\n          if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n\n            // Use DRACO geometry if available\n            geometryPromise = createDracoPrimitive(primitive);\n\n          } else {\n\n            // Otherwise create a new geometry\n            geometryPromise = addPrimitiveAttributes(new THREE.BufferGeometry(), primitive, parser);\n\n          }\n\n          // Cache this geometry\n          cache[cacheKey] = { primitive: primitive, promise: geometryPromise };\n\n          pending.push(geometryPromise);\n\n        }\n\n      }\n\n      return Promise.all(pending);\n\n    };\n\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n     * @param {number} meshIndex\n     * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}\n     */\n    GLTFParser.prototype.loadMesh = function (meshIndex) {\n\n      var parser = this;\n      var json = this.json;\n\n      var meshDef = json.meshes[meshIndex];\n      var primitives = meshDef.primitives;\n\n      var pending = [];\n\n      for (var i = 0, il = primitives.length; i < il; i++) {\n\n        var material = primitives[i].material === undefined\n          ? createDefaultMaterial()\n          : this.getDependency('material', primitives[i].material);\n\n        pending.push(material);\n\n      }\n\n      return Promise.all(pending).then(function (originalMaterials) {\n\n        return parser.loadGeometries(primitives).then(function (geometries) {\n\n          var meshes = [];\n\n          for (var i = 0, il = geometries.length; i < il; i++) {\n\n            var geometry = geometries[i];\n            var primitive = primitives[i];\n\n            // 1. create Mesh\n\n            var mesh;\n\n            var material = originalMaterials[i];\n\n            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n              primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n              primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n              primitive.mode === undefined) {\n\n              // .isSkinnedMesh isn't in glTF spec. See .markDefs()\n              mesh = meshDef.isSkinnedMesh === true\n                ? new THREE.SkinnedMesh(geometry, material)\n                : new THREE.Mesh(geometry, material);\n\n              if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {\n\n                // we normalize floating point skin weight array to fix malformed assets (see #15319)\n                // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n                mesh.normalizeSkinWeights();\n\n              }\n\n              if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n\n                mesh.drawMode = THREE.TriangleStripDrawMode;\n\n              } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n\n                mesh.drawMode = THREE.TriangleFanDrawMode;\n\n              }\n\n            } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n\n              mesh = new THREE.LineSegments(geometry, material);\n\n            } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n\n              mesh = new THREE.Line(geometry, material);\n\n            } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n\n              mesh = new THREE.LineLoop(geometry, material);\n\n            } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n\n              mesh = new THREE.Points(geometry, material);\n\n            } else {\n\n              throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\n\n            }\n\n            if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n\n              updateMorphTargets(mesh, meshDef);\n\n            }\n\n            mesh.name = meshDef.name || ('mesh_' + meshIndex);\n\n            if (geometries.length > 1) mesh.name += '_' + i;\n\n            assignExtrasToUserData(mesh, meshDef);\n\n            parser.assignFinalMaterial(mesh);\n\n            meshes.push(mesh);\n\n          }\n\n          if (meshes.length === 1) {\n\n            return meshes[0];\n\n          }\n\n          var group = new THREE.Group();\n\n          for (var i = 0, il = meshes.length; i < il; i++) {\n\n            group.add(meshes[i]);\n\n          }\n\n          return group;\n\n        });\n\n      });\n\n    };\n\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n     * @param {number} cameraIndex\n     * @return {Promise<THREE.Camera>}\n     */\n    GLTFParser.prototype.loadCamera = function (cameraIndex) {\n\n      var camera;\n      var cameraDef = this.json.cameras[cameraIndex];\n      var params = cameraDef[cameraDef.type];\n\n      if (!params) {\n\n        console.warn('THREE.GLTFLoader: Missing camera parameters.');\n        return;\n\n      }\n\n      if (cameraDef.type === 'perspective') {\n\n        camera = new THREE.PerspectiveCamera(THREE.Math.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n\n      } else if (cameraDef.type === 'orthographic') {\n\n        camera = new THREE.OrthographicCamera(params.xmag / - 2, params.xmag / 2, params.ymag / 2, params.ymag / - 2, params.znear, params.zfar);\n\n      }\n\n      if (cameraDef.name !== undefined) camera.name = cameraDef.name;\n\n      assignExtrasToUserData(camera, cameraDef);\n\n      return Promise.resolve(camera);\n\n    };\n\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n     * @param {number} skinIndex\n     * @return {Promise<Object>}\n     */\n    GLTFParser.prototype.loadSkin = function (skinIndex) {\n\n      var skinDef = this.json.skins[skinIndex];\n\n      var skinEntry = { joints: skinDef.joints };\n\n      if (skinDef.inverseBindMatrices === undefined) {\n\n        return Promise.resolve(skinEntry);\n\n      }\n\n      return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\n\n        skinEntry.inverseBindMatrices = accessor;\n\n        return skinEntry;\n\n      });\n\n    };\n\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n     * @param {number} animationIndex\n     * @return {Promise<THREE.AnimationClip>}\n     */\n    GLTFParser.prototype.loadAnimation = function (animationIndex) {\n\n      var json = this.json;\n\n      var animationDef = json.animations[animationIndex];\n\n      var pendingNodes = [];\n      var pendingInputAccessors = [];\n      var pendingOutputAccessors = [];\n      var pendingSamplers = [];\n      var pendingTargets = [];\n\n      for (var i = 0, il = animationDef.channels.length; i < il; i++) {\n\n        var channel = animationDef.channels[i];\n        var sampler = animationDef.samplers[channel.sampler];\n        var target = channel.target;\n        var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n        var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n        var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n\n        pendingNodes.push(this.getDependency('node', name));\n        pendingInputAccessors.push(this.getDependency('accessor', input));\n        pendingOutputAccessors.push(this.getDependency('accessor', output));\n        pendingSamplers.push(sampler);\n        pendingTargets.push(target);\n\n      }\n\n      return Promise.all([\n\n        Promise.all(pendingNodes),\n        Promise.all(pendingInputAccessors),\n        Promise.all(pendingOutputAccessors),\n        Promise.all(pendingSamplers),\n        Promise.all(pendingTargets)\n\n      ]).then(function (dependencies) {\n\n        var nodes = dependencies[0];\n        var inputAccessors = dependencies[1];\n        var outputAccessors = dependencies[2];\n        var samplers = dependencies[3];\n        var targets = dependencies[4];\n\n        var tracks = [];\n\n        for (var i = 0, il = nodes.length; i < il; i++) {\n\n          var node = nodes[i];\n          var inputAccessor = inputAccessors[i];\n          var outputAccessor = outputAccessors[i];\n          var sampler = samplers[i];\n          var target = targets[i];\n\n          if (node === undefined) continue;\n\n          node.updateMatrix();\n          node.matrixAutoUpdate = true;\n\n          var TypedKeyframeTrack;\n\n          switch (PATH_PROPERTIES[target.path]) {\n\n            case PATH_PROPERTIES.weights:\n\n              TypedKeyframeTrack = THREE.NumberKeyframeTrack;\n              break;\n\n            case PATH_PROPERTIES.rotation:\n\n              TypedKeyframeTrack = THREE.QuaternionKeyframeTrack;\n              break;\n\n            case PATH_PROPERTIES.position:\n            case PATH_PROPERTIES.scale:\n            default:\n\n              TypedKeyframeTrack = THREE.VectorKeyframeTrack;\n              break;\n\n          }\n\n          var targetName = node.name ? node.name : node.uuid;\n\n          var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear;\n\n          var targetNames = [];\n\n          if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n\n            // Node may be a THREE.Group (glTF mesh with several primitives) or a THREE.Mesh.\n            node.traverse(function (object) {\n\n              if (object.isMesh === true && object.morphTargetInfluences) {\n\n                targetNames.push(object.name ? object.name : object.uuid);\n\n              }\n\n            });\n\n          } else {\n\n            targetNames.push(targetName);\n\n          }\n\n          var outputArray = outputAccessor.array;\n\n          if (outputAccessor.normalized) {\n\n            var scale;\n\n            if (outputArray.constructor === Int8Array) {\n\n              scale = 1 / 127;\n\n            } else if (outputArray.constructor === Uint8Array) {\n\n              scale = 1 / 255;\n\n            } else if (outputArray.constructor == Int16Array) {\n\n              scale = 1 / 32767;\n\n            } else if (outputArray.constructor === Uint16Array) {\n\n              scale = 1 / 65535;\n\n            } else {\n\n              throw new Error('THREE.GLTFLoader: Unsupported output accessor component type.');\n\n            }\n\n            var scaled = new Float32Array(outputArray.length);\n\n            for (var j = 0, jl = outputArray.length; j < jl; j++) {\n\n              scaled[j] = outputArray[j] * scale;\n\n            }\n\n            outputArray = scaled;\n\n          }\n\n          for (var j = 0, jl = targetNames.length; j < jl; j++) {\n\n            var track = new TypedKeyframeTrack(\n              targetNames[j] + '.' + PATH_PROPERTIES[target.path],\n              inputAccessor.array,\n              outputArray,\n              interpolation\n            );\n\n            // Override interpolation with custom factory method.\n            if (sampler.interpolation === 'CUBICSPLINE') {\n\n              track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n\n                // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n                // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n                // must be divided by three to get the interpolant's sampleSize argument.\n\n                return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);\n\n              };\n\n              // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n              track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n            }\n\n            tracks.push(track);\n\n          }\n\n        }\n\n        var name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;\n\n        return new THREE.AnimationClip(name, undefined, tracks);\n\n      });\n\n    };\n\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n     * @param {number} nodeIndex\n     * @return {Promise<THREE.Object3D>}\n     */\n    GLTFParser.prototype.loadNode = function (nodeIndex) {\n\n      var json = this.json;\n      var extensions = this.extensions;\n      var parser = this;\n\n      var meshReferences = json.meshReferences;\n      var meshUses = json.meshUses;\n\n      var nodeDef = json.nodes[nodeIndex];\n\n      return (function () {\n\n        var pending = [];\n\n        if (nodeDef.mesh !== undefined) {\n\n          pending.push(parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n\n            var node;\n\n            if (meshReferences[nodeDef.mesh] > 1) {\n\n              var instanceNum = meshUses[nodeDef.mesh]++;\n\n              node = mesh.clone();\n              node.name += '_instance_' + instanceNum;\n\n              // onBeforeRender copy for Specular-Glossiness\n              node.onBeforeRender = mesh.onBeforeRender;\n\n              for (var i = 0, il = node.children.length; i < il; i++) {\n\n                node.children[i].name += '_instance_' + instanceNum;\n                node.children[i].onBeforeRender = mesh.children[i].onBeforeRender;\n\n              }\n\n            } else {\n\n              node = mesh;\n\n            }\n\n            // if weights are provided on the node, override weights on the mesh.\n            if (nodeDef.weights !== undefined) {\n\n              node.traverse(function (o) {\n\n                if (!o.isMesh) return;\n\n                for (var i = 0, il = nodeDef.weights.length; i < il; i++) {\n\n                  o.morphTargetInfluences[i] = nodeDef.weights[i];\n\n                }\n\n              });\n\n            }\n\n            return node;\n\n          }));\n\n        }\n\n        if (nodeDef.camera !== undefined) {\n\n          pending.push(parser.getDependency('camera', nodeDef.camera));\n\n        }\n\n        if (nodeDef.extensions\n          && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL]\n          && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== undefined) {\n\n          pending.push(parser.getDependency('light', nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light));\n\n        }\n\n        return Promise.all(pending);\n\n      }()).then(function (objects) {\n\n        var node;\n\n        // .isBone isn't in glTF spec. See .markDefs\n        if (nodeDef.isBone === true) {\n\n          node = new THREE.Bone();\n\n        } else if (objects.length > 1) {\n\n          node = new THREE.Group();\n\n        } else if (objects.length === 1) {\n\n          node = objects[0];\n\n        } else {\n\n          node = new THREE.Object3D();\n\n        }\n\n        if (node !== objects[0]) {\n\n          for (var i = 0, il = objects.length; i < il; i++) {\n\n            node.add(objects[i]);\n\n          }\n\n        }\n\n        if (nodeDef.name !== undefined) {\n\n          node.userData.name = nodeDef.name;\n          node.name = THREE.PropertyBinding.sanitizeNodeName(nodeDef.name);\n\n        }\n\n        assignExtrasToUserData(node, nodeDef);\n\n        if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n\n        if (nodeDef.matrix !== undefined) {\n\n          var matrix = new THREE.Matrix4();\n          matrix.fromArray(nodeDef.matrix);\n          node.applyMatrix(matrix);\n\n        } else {\n\n          if (nodeDef.translation !== undefined) {\n\n            node.position.fromArray(nodeDef.translation);\n\n          }\n\n          if (nodeDef.rotation !== undefined) {\n\n            node.quaternion.fromArray(nodeDef.rotation);\n\n          }\n\n          if (nodeDef.scale !== undefined) {\n\n            node.scale.fromArray(nodeDef.scale);\n\n          }\n\n        }\n\n        return node;\n\n      });\n\n    };\n\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n     * @param {number} sceneIndex\n     * @return {Promise<THREE.Scene>}\n     */\n    GLTFParser.prototype.loadScene = function () {\n\n      // scene node hierachy builder\n\n      function buildNodeHierachy(nodeId, parentObject, json, parser) {\n\n        var nodeDef = json.nodes[nodeId];\n\n        return parser.getDependency('node', nodeId).then(function (node) {\n\n          if (nodeDef.skin === undefined) return node;\n\n          // build skeleton here as well\n\n          var skinEntry;\n\n          return parser.getDependency('skin', nodeDef.skin).then(function (skin) {\n\n            skinEntry = skin;\n\n            var pendingJoints = [];\n\n            for (var i = 0, il = skinEntry.joints.length; i < il; i++) {\n\n              pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));\n\n            }\n\n            return Promise.all(pendingJoints);\n\n          }).then(function (jointNodes) {\n\n            node.traverse(function (mesh) {\n\n              if (!mesh.isMesh) return;\n\n              var bones = [];\n              var boneInverses = [];\n\n              for (var j = 0, jl = jointNodes.length; j < jl; j++) {\n\n                var jointNode = jointNodes[j];\n\n                if (jointNode) {\n\n                  bones.push(jointNode);\n\n                  var mat = new THREE.Matrix4();\n\n                  if (skinEntry.inverseBindMatrices !== undefined) {\n\n                    mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n\n                  }\n\n                  boneInverses.push(mat);\n\n                } else {\n\n                  console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[j]);\n\n                }\n\n              }\n\n              mesh.bind(new THREE.Skeleton(bones, boneInverses), mesh.matrixWorld);\n\n            });\n\n            return node;\n\n          });\n\n        }).then(function (node) {\n\n          // build node hierachy\n\n          parentObject.add(node);\n\n          var pending = [];\n\n          if (nodeDef.children) {\n\n            var children = nodeDef.children;\n\n            for (var i = 0, il = children.length; i < il; i++) {\n\n              var child = children[i];\n              pending.push(buildNodeHierachy(child, node, json, parser));\n\n            }\n\n          }\n\n          return Promise.all(pending);\n\n        });\n\n      }\n\n      return function loadScene(sceneIndex) {\n\n        var json = this.json;\n        var extensions = this.extensions;\n        var sceneDef = this.json.scenes[sceneIndex];\n        var parser = this;\n\n        var scene = new THREE.Scene();\n        if (sceneDef.name !== undefined) scene.name = sceneDef.name;\n\n        assignExtrasToUserData(scene, sceneDef);\n\n        if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n\n        var nodeIds = sceneDef.nodes || [];\n\n        var pending = [];\n\n        for (var i = 0, il = nodeIds.length; i < il; i++) {\n\n          pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));\n\n        }\n\n        return Promise.all(pending).then(function () {\n\n          return scene;\n\n        });\n\n      };\n\n    }();\n\n    return GLTFLoader;\n\n  })();\n}"],"names":["uni","attributeName","i","il","target","sourceURI","accessor","primitive","material","sampler","name"],"mappings":"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"}